#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Назаров В.И.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Для обработки естественных и искусственных языков обычно применяются три подхода: статистический метод, метод правил и шаблонов, метод машинного обучения. Статистический подход используется для выявления закономерностей и шаблонов в тексте. В методе правил и шаблонов используются явно заданные правила и шаблоны для анализа и обработки текста. Методы машинного обучения используются для обучения моделей на больших объемах текстовых данных.

Prolog оказывается удобным языком для решения таких задач, потому что Prolog основан на логическом программировании, что делает его удобным для формулирования и решения задач, связанных с обработкой языка. Также этот язык позволяет легко работать с базами знаний и формулировать логические отношения между объектами и событиями, кроме этого эти базы данных можно расширять и модифицировать.

## Задание

Вариант 9. Реализовать разбор фраз языка (вопросов), выделяя в них неизвестный объекты.
```
Запрос: ?- an_q([“Кто”, “любит”, “шоколад” “?”],X) 
        ?- an_q([“Где”, “лежат”, “деньги” “?”],X) 
        ?- an_q([“Что”, “любит”, “Даша” “?”],X)
Результат: X=’любить’(agent(Y), object(’шоколад’)), 
           X=’лежать’(object(‘деньги’), loc(X)), 
           X=’любить’(agent(“Даша”), object(Y)).
```
## Принцип решения

В начале программы создадим спсики со словами, которые могут быть использованы для постановки вопроса, а также запишем формы глаголов, которые в дальнейшем будем использовать для вывода результата.

```
% Список форм глаголов
verb('любить', ['любить', 'любит']).
verb('лежать', ['лежать', 'лежат']).
verb('хотеть', ['хочешь', 'хочет']).

% Список вопросов
question('Кто', agent).
question('Кому', agent).
question('Чей', agent).

question('Что', object).
question('Чего', object).
question('Чему', object).

question('Где', location).

% Список слов
slovo('тут', location).
slovo('здесь', location).
slovo('там', location).

slovo('Даша', agent).
slovo('Маша', agent).
slovo('Миша', agent).
slovo('Саша', agent).

slovo('шоколад', object).
slovo('деньги', object).
slovo('клад', object).
slovo('мороженое', object).
```

Создадим предикат `concat_strings` для конкатенации, то есть для объединения списка строк в одну строку. Кроме этого напишем `find_form` для поиска соответствующей формы глагола, основываясь на заданной форме и `write_verb` для формирования строки, представляющей глагол и его аргументы.

```
% Конкатенация
concat_strings(StringList, StringResult) :- maplist(atom_chars, StringList, CharList), append(CharList, Char), atom_chars(StringResult, Char).

% Поиск формы глагола
find_form(Form, Result) :- verb(Result, Char), member(Form, Char).

% Формирование строки в нужном формате
write_verb(Action, FPred, FArg, SPred, SArg, Result) :- concat_strings([Action, '(', FPred, '(', FArg, '), ', SPred, '(', SArg, ')', ')'], Result).
```

Предикаты `verb` используются для организации и обработки глаголов с различными аргументами в предложениях: подлежащего, объекта, локации. `an_q` - основной предикат, который используется для обработки вопросительных предложений и создания строки с соответствующим форматом вывода.

```
% Обработка глаголов с подлежащим
verb(agent, SType, S, Action, Result) :- write_verb(Action, agent, 'Y', SType, S, Result).

% Обработка глаголов с объектом
verb(object, SType, S, Action, Result) :- write_verb(Action, SType, S, object, 'Y', Result).

% Обработка глаголов с местоположением
verb(location, SType, S, Action, Result) :- write_verb(Action, SType, S, location, 'Y', Result).

% Обработка входных вопросов
an_q([Question, Action, Subject, '?'], X) :- find_form(Action, NormAction), question(Question, Q), slovo(Subject, SType), verb(Q, SType, Subject, NormAction, X), !.
```
## Результаты

```
?- an_q(['Кто', 'любит', 'шоколад', '?'], X).
X = 'любить(agent(Y), object(шоколад))'.

?- an_q(['Что', 'любит', 'Даша', '?'], X).
X = 'любить(agent(Даша), object(Y))'.

?- an_q(['Где', 'лежат', 'деньги', '?'], X).
X = 'лежать(object(деньги), location(Y))'.
```

## Выводы

В ходе лабораторной работы я на практике познакомился с методами анализа естественных языков в системе логического программирования. Я понял, что Prolog является удобным инструментом для решения задач грамматического разбора, благодаря своей основе на логическом программировании, удобству работы с базами данных.
Prolog предоставляет гибкие инструменты для формулирования и решения задач обработки естественного языка, что дает ему преимущества в выборе подходящего языка для решения подобных задач.



