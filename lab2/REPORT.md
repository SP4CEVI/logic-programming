#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Назаров В.И.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Для решения логических задач существует много методов, но основными можно назвать: перебор вариантов, метод исключения. Также многие способы сводятся именно к этим двум. Метод перебора - спососб решения задачи, в котором все возможные варианты комбинаций проверяются последовательно, пока не будет найдено нужное решение или все возможные варианты не будут исчерпаны. Метод исключения - способ решения задачи, в котором последовательно исключаются неправильные варианты, пока не останется только правильное решение. 

Prolog является удобным языком для решения таких задач, потому что этот язык позволяет программировать декларативно, описывая факты и правила, то есть можно описать то, что нужно сделать, а не как это сделать. На Prolog удобно реализовать предикаты решения задачи и применить метод перебора возможных вариантов, записав факты из задачи.

## Задание

Кондратьев, Давыдов и Федоров живут на нашей улице. Один из них столяр, другой маляр, третий водопроводчик. Недавно маляр хотел попросить своего знакомого столяра сделать кое-что для своей квартиры, но ему сказали, что столяр работает в доме водопроводчика. Известно также, что Федоров никогда не слышал о Давыдове. Кто чем занимается?

## Принцип решения
Эту задачу можно решить методами перебора и исключения. Метод перебора применяется при использовании предиката `professions`, а метод исключения в предикате `all_different`. 
В начале реализуется рекурсивный предикат для гарантии, что нет повторяющихся значений профессий:
```prolog
all_different([]).
all_different([H|T]) :- not(member(H, T)), all_different(T).
```
После этого реализуется предикат `contradiction` определяющий возможные значения профессий и героев задачи:
```prolog
professions([stolyar, malyar, vodoprovodchik]).
```
После этого внутри конечного предиката `solve` записываются известные факты из условия задачи:
```prolog
solve(K, D, F) :-

    professions([K, D, F]),

    % Каждый из них имеет различную профессию
    all_different([K, D, F]),

    % Один из них столяр, другой маляр, третий водопроводчик
    (K = stolyar; K = malyar; K = vodoprovodchik),
    (D = stolyar; D = malyar; D = vodoprovodchik),
    (F = stolyar; F = malyar; F = vodoprovodchik),

    % Маляр слышал про водопроводчика от столяра, но водопроводчик не слышал про маляра
    not((K = malyar, F = vodoprovodchik)),

    % Федоров никогда не слышал о Давыдове
    not(F = D).
```

Результат работы программы:
```prolog
?- solve(K, D, F).
K = stolyar,
D = malyar,
F = vodoprovodchik.

```
Программа является безопасной, так как записываются все известные факты и используется проверка условий. Программа довольно эффективная, благодаря предикату `all_different`и ограничениям, которые заведомо отсеивают некоторые комбинации. Программа использует перебор всех возможных комбинаций профессий для каждого из трех человек, поэтому сложность программы будет O(n^3), где n - количество возможных профессий, но в конкретно этой задаче 3 профессии, поэтому 3^3.

## Выводы

В ходе лабораторной работы я приобрел навыки решения логических задач на Prolog, который является очень удобным инструментом для решения задач подобного типа. Я подтвердил тот факт, что в Prolog не нужно писать то, как решать задачу, достаточно написать известные факты и перебрать все возможные варианты. Решение логических задач с помощью Prolog сильно проще и экономит время по сравнению с решением "на листочке", особенно при большом количестве данных. Prolog самостоятельно перебирает все возможные комбинации и находит правильное решение, основываясь на заданных условиях. Такой подход полезен, когда задачи становятся сложнее и требуют обработки большого объема данных. 



